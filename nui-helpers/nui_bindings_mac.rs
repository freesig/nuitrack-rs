/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type __uint8_t = ::std::os::raw::c_uchar;
    pub type __uint16_t = ::std::os::raw::c_ushort;
    pub type __uint64_t = ::std::os::raw::c_ulong;
    pub mod tdv {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod nuitrack {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Vector3 {
                pub x: f32,
                pub y: f32,
                pub z: f32,
            }
            #[test]
            fn bindgen_test_layout_Vector3() {
                assert_eq!(
                    ::std::mem::size_of::<Vector3>(),
                    12usize,
                    concat!("Size of: ", stringify!(Vector3))
                );
                assert_eq!(
                    ::std::mem::align_of::<Vector3>(),
                    4usize,
                    concat!("Alignment of ", stringify!(Vector3))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Vector3>())).x as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector3),
                        "::",
                        stringify!(x)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Vector3>())).y as *const _ as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector3),
                        "::",
                        stringify!(y)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Vector3>())).z as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Vector3),
                        "::",
                        stringify!(z)
                    )
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Color3 {
                pub blue: u8,
                pub green: u8,
                pub red: u8,
            }
            #[test]
            fn bindgen_test_layout_Color3() {
                assert_eq!(
                    ::std::mem::size_of::<Color3>(),
                    3usize,
                    concat!("Size of: ", stringify!(Color3))
                );
                assert_eq!(
                    ::std::mem::align_of::<Color3>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Color3))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Color3>())).blue as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color3),
                        "::",
                        stringify!(blue)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Color3>())).green as *const _ as usize },
                    1usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color3),
                        "::",
                        stringify!(green)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Color3>())).red as *const _ as usize },
                    2usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Color3),
                        "::",
                        stringify!(red)
                    )
                );
            }
            /// @ingroup UserTracker_group
            /// @brief Stores a bounding box properties.
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct BoundingBox {
                ///< Position of the top face of the bounding box
                pub top: f32,
                ///< Position of the bottom face of the bounding box
                pub bottom: f32,
                ///< Position of the left face of the bounding box
                pub left: f32,
                ///< Position of the right face of the bounding box
                pub right: f32,
            }
            #[test]
            fn bindgen_test_layout_BoundingBox() {
                assert_eq!(
                    ::std::mem::size_of::<BoundingBox>(),
                    16usize,
                    concat!("Size of: ", stringify!(BoundingBox))
                );
                assert_eq!(
                    ::std::mem::align_of::<BoundingBox>(),
                    4usize,
                    concat!("Alignment of ", stringify!(BoundingBox))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<BoundingBox>())).top as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BoundingBox),
                        "::",
                        stringify!(top)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<BoundingBox>())).bottom as *const _ as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BoundingBox),
                        "::",
                        stringify!(bottom)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<BoundingBox>())).left as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BoundingBox),
                        "::",
                        stringify!(left)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<BoundingBox>())).right as *const _ as usize },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BoundingBox),
                        "::",
                        stringify!(right)
                    )
                );
            }
            /// @ingroup UserTracker_group
            /// @brief Stores information about a detected user.
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct User {
                /// @brief %User identifier.
                pub id: ::std::os::raw::c_int,
                /// @brief Center of mass in projective coordinates.
                pub proj: root::tdv::nuitrack::Vector3,
                /// @brief Center of mass in real coordinates.
                pub real: root::tdv::nuitrack::Vector3,
                /// @brief Bounding box
                ///
                /// Face positions are given in normalized floating-point coordinates in range [0;1].
                pub box_: root::tdv::nuitrack::BoundingBox,
                /// @brief Occlusion rate in range [0;1]
                pub occlusion: f32,
            }
            #[test]
            fn bindgen_test_layout_User() {
                assert_eq!(
                    ::std::mem::size_of::<User>(),
                    48usize,
                    concat!("Size of: ", stringify!(User))
                );
                assert_eq!(
                    ::std::mem::align_of::<User>(),
                    4usize,
                    concat!("Alignment of ", stringify!(User))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<User>())).id as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(User), "::", stringify!(id))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<User>())).proj as *const _ as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(User),
                        "::",
                        stringify!(proj)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<User>())).real as *const _ as usize },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(User),
                        "::",
                        stringify!(real)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<User>())).box_ as *const _ as usize },
                    28usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(User),
                        "::",
                        stringify!(box_)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<User>())).occlusion as *const _ as usize },
                    44usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(User),
                        "::",
                        stringify!(occlusion)
                    )
                );
            }
            /// @ingroup CommonElements_group
            /// @brief Stores the spatial orientation as a 3x3 rotation matrix.
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Orientation {
                /// @brief Flattened 3x3 rotation matrix.
                pub matrix: [f32; 9usize],
            }
            #[test]
            fn bindgen_test_layout_Orientation() {
                assert_eq!(
                    ::std::mem::size_of::<Orientation>(),
                    36usize,
                    concat!("Size of: ", stringify!(Orientation))
                );
                assert_eq!(
                    ::std::mem::align_of::<Orientation>(),
                    4usize,
                    concat!("Alignment of ", stringify!(Orientation))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Orientation>())).matrix as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Orientation),
                        "::",
                        stringify!(matrix)
                    )
                );
            }
            ///< Reserved joint (unused).
            pub const JointType_JOINT_NONE: root::tdv::nuitrack::JointType = 0;
            ///< Head
            pub const JointType_JOINT_HEAD: root::tdv::nuitrack::JointType = 1;
            ///< Neck
            pub const JointType_JOINT_NECK: root::tdv::nuitrack::JointType = 2;
            ///< Torso
            pub const JointType_JOINT_TORSO: root::tdv::nuitrack::JointType = 3;
            ///< Waist
            pub const JointType_JOINT_WAIST: root::tdv::nuitrack::JointType = 4;
            ///< Left collar
            pub const JointType_JOINT_LEFT_COLLAR: root::tdv::nuitrack::JointType = 5;
            ///< Left shoulder
            pub const JointType_JOINT_LEFT_SHOULDER: root::tdv::nuitrack::JointType = 6;
            ///< Left elbow
            pub const JointType_JOINT_LEFT_ELBOW: root::tdv::nuitrack::JointType = 7;
            ///< Left wrist
            pub const JointType_JOINT_LEFT_WRIST: root::tdv::nuitrack::JointType = 8;
            ///< Left hand
            pub const JointType_JOINT_LEFT_HAND: root::tdv::nuitrack::JointType = 9;
            ///< Left fingertip (<b>not used in the current version</b>).
            pub const JointType_JOINT_LEFT_FINGERTIP: root::tdv::nuitrack::JointType = 10;
            ///< Right collar
            pub const JointType_JOINT_RIGHT_COLLAR: root::tdv::nuitrack::JointType = 11;
            ///< Right shoulder
            pub const JointType_JOINT_RIGHT_SHOULDER: root::tdv::nuitrack::JointType = 12;
            ///< Right elbow
            pub const JointType_JOINT_RIGHT_ELBOW: root::tdv::nuitrack::JointType = 13;
            ///< Right wrist
            pub const JointType_JOINT_RIGHT_WRIST: root::tdv::nuitrack::JointType = 14;
            ///< Right hand
            pub const JointType_JOINT_RIGHT_HAND: root::tdv::nuitrack::JointType = 15;
            ///< Right fingertip (<b>not used in the current version</b>).
            pub const JointType_JOINT_RIGHT_FINGERTIP: root::tdv::nuitrack::JointType = 16;
            ///< Left hip
            pub const JointType_JOINT_LEFT_HIP: root::tdv::nuitrack::JointType = 17;
            ///< Left knee
            pub const JointType_JOINT_LEFT_KNEE: root::tdv::nuitrack::JointType = 18;
            ///< Left ankle
            pub const JointType_JOINT_LEFT_ANKLE: root::tdv::nuitrack::JointType = 19;
            ///< Left foot (<b>not used in the current version</b>).
            pub const JointType_JOINT_LEFT_FOOT: root::tdv::nuitrack::JointType = 20;
            ///< Right hip
            pub const JointType_JOINT_RIGHT_HIP: root::tdv::nuitrack::JointType = 21;
            ///< Right knee
            pub const JointType_JOINT_RIGHT_KNEE: root::tdv::nuitrack::JointType = 22;
            ///< Right ankle
            pub const JointType_JOINT_RIGHT_ANKLE: root::tdv::nuitrack::JointType = 23;
            ///< Right foot (<b>not used in the current version</b>).
            pub const JointType_JOINT_RIGHT_FOOT: root::tdv::nuitrack::JointType = 24;
            /// @ingroup SkeletonTracker_group
            /// @brief Joint index meaning (please note that <i>JOINT_LEFT_FINGERTIP, JOINT_RIGHT_FINGERTIP, JOINT_LEFT_FOOT, JOINT_RIGHT_FOOT</i> are not used in the current version).
            pub type JointType = u32;
            /// @ingroup SkeletonTracker_group
            /// @brief Stores the joint data.
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Joint {
                /// @brief %Joint type.
                pub type_: root::tdv::nuitrack::JointType,
                /// @brief %Joint confidence from 0.0 to 1.0. Larger value means more confident joint.
                pub confidence: f32,
                /// @brief %Joint position in real world coordinates.
                pub real: root::tdv::nuitrack::Vector3,
                /// @brief %Joint position in normalized projective coordinates
                /// (x, y from 0.0 to 1.0, z is real).
                pub proj: root::tdv::nuitrack::Vector3,
                /// @brief %Joint orientation.
                pub orient: root::tdv::nuitrack::Orientation,
            }
            #[test]
            fn bindgen_test_layout_Joint() {
                assert_eq!(
                    ::std::mem::size_of::<Joint>(),
                    68usize,
                    concat!("Size of: ", stringify!(Joint))
                );
                assert_eq!(
                    ::std::mem::align_of::<Joint>(),
                    4usize,
                    concat!("Alignment of ", stringify!(Joint))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Joint>())).type_ as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Joint),
                        "::",
                        stringify!(type_)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Joint>())).confidence as *const _ as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Joint),
                        "::",
                        stringify!(confidence)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Joint>())).real as *const _ as usize },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Joint),
                        "::",
                        stringify!(real)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Joint>())).proj as *const _ as usize },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Joint),
                        "::",
                        stringify!(proj)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Joint>())).orient as *const _ as usize },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Joint),
                        "::",
                        stringify!(orient)
                    )
                );
            }
        }
    }
    pub mod simple {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Skeleton {
            pub id: ::std::os::raw::c_int,
            pub num_joints: usize,
            pub joints: *const root::tdv::nuitrack::Joint,
        }
        #[test]
        fn bindgen_test_layout_Skeleton() {
            assert_eq!(
                ::std::mem::size_of::<Skeleton>(),
                24usize,
                concat!("Size of: ", stringify!(Skeleton))
            );
            assert_eq!(
                ::std::mem::align_of::<Skeleton>(),
                8usize,
                concat!("Alignment of ", stringify!(Skeleton))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Skeleton>())).id as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Skeleton),
                    "::",
                    stringify!(id)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Skeleton>())).num_joints as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Skeleton),
                    "::",
                    stringify!(num_joints)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Skeleton>())).joints as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Skeleton),
                    "::",
                    stringify!(joints)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SkeletonData {
            pub skeletons: *mut root::simple::Skeleton,
            pub len: usize,
        }
        #[test]
        fn bindgen_test_layout_SkeletonData() {
            assert_eq!(
                ::std::mem::size_of::<SkeletonData>(),
                16usize,
                concat!("Size of: ", stringify!(SkeletonData))
            );
            assert_eq!(
                ::std::mem::align_of::<SkeletonData>(),
                8usize,
                concat!("Alignment of ", stringify!(SkeletonData))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SkeletonData>())).skeletons as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SkeletonData),
                    "::",
                    stringify!(skeletons)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<SkeletonData>())).len as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(SkeletonData),
                    "::",
                    stringify!(len)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DepthFrame {
            pub rows: ::std::os::raw::c_int,
            pub cols: ::std::os::raw::c_int,
            pub id: u64,
            pub data: *const u16,
            pub time_stamp: u64,
        }
        #[test]
        fn bindgen_test_layout_DepthFrame() {
            assert_eq!(
                ::std::mem::size_of::<DepthFrame>(),
                32usize,
                concat!("Size of: ", stringify!(DepthFrame))
            );
            assert_eq!(
                ::std::mem::align_of::<DepthFrame>(),
                8usize,
                concat!("Alignment of ", stringify!(DepthFrame))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<DepthFrame>())).rows as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DepthFrame),
                    "::",
                    stringify!(rows)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<DepthFrame>())).cols as *const _ as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DepthFrame),
                    "::",
                    stringify!(cols)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<DepthFrame>())).id as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DepthFrame),
                    "::",
                    stringify!(id)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<DepthFrame>())).data as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DepthFrame),
                    "::",
                    stringify!(data)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<DepthFrame>())).time_stamp as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(DepthFrame),
                    "::",
                    stringify!(time_stamp)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RGBFrame {
            pub rows: ::std::os::raw::c_int,
            pub cols: ::std::os::raw::c_int,
            pub id: u64,
            pub data: *const root::tdv::nuitrack::Color3,
            pub time_stamp: u64,
        }
        #[test]
        fn bindgen_test_layout_RGBFrame() {
            assert_eq!(
                ::std::mem::size_of::<RGBFrame>(),
                32usize,
                concat!("Size of: ", stringify!(RGBFrame))
            );
            assert_eq!(
                ::std::mem::align_of::<RGBFrame>(),
                8usize,
                concat!("Alignment of ", stringify!(RGBFrame))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RGBFrame>())).rows as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RGBFrame),
                    "::",
                    stringify!(rows)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RGBFrame>())).cols as *const _ as usize },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RGBFrame),
                    "::",
                    stringify!(cols)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RGBFrame>())).id as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RGBFrame),
                    "::",
                    stringify!(id)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RGBFrame>())).data as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RGBFrame),
                    "::",
                    stringify!(data)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<RGBFrame>())).time_stamp as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(RGBFrame),
                    "::",
                    stringify!(time_stamp)
                )
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct UserFrame {
            pub num_users: usize,
            pub users: *mut root::tdv::nuitrack::User,
            pub rows: ::std::os::raw::c_int,
            pub cols: ::std::os::raw::c_int,
            pub id: u64,
            pub data: *const u16,
            pub time_stamp: u64,
            pub floor: root::tdv::nuitrack::Vector3,
            pub floor_normal: root::tdv::nuitrack::Vector3,
        }
        #[test]
        fn bindgen_test_layout_UserFrame() {
            assert_eq!(
                ::std::mem::size_of::<UserFrame>(),
                72usize,
                concat!("Size of: ", stringify!(UserFrame))
            );
            assert_eq!(
                ::std::mem::align_of::<UserFrame>(),
                8usize,
                concat!("Alignment of ", stringify!(UserFrame))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UserFrame>())).num_users as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UserFrame),
                    "::",
                    stringify!(num_users)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UserFrame>())).users as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UserFrame),
                    "::",
                    stringify!(users)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UserFrame>())).rows as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UserFrame),
                    "::",
                    stringify!(rows)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UserFrame>())).cols as *const _ as usize },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UserFrame),
                    "::",
                    stringify!(cols)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UserFrame>())).id as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UserFrame),
                    "::",
                    stringify!(id)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UserFrame>())).data as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UserFrame),
                    "::",
                    stringify!(data)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UserFrame>())).time_stamp as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UserFrame),
                    "::",
                    stringify!(time_stamp)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UserFrame>())).floor as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UserFrame),
                    "::",
                    stringify!(floor)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<UserFrame>())).floor_normal as *const _ as usize },
                60usize,
                concat!(
                    "Offset of field: ",
                    stringify!(UserFrame),
                    "::",
                    stringify!(floor_normal)
                )
            );
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Nothing {
        pub _address: u8,
    }
    #[test]
    fn bindgen_test_layout_Nothing() {
        assert_eq!(
            ::std::mem::size_of::<Nothing>(),
            1usize,
            concat!("Size of: ", stringify!(Nothing))
        );
        assert_eq!(
            ::std::mem::align_of::<Nothing>(),
            1usize,
            concat!("Alignment of ", stringify!(Nothing))
        );
    }
    pub const Tag_Err: root::Tag = -1;
    pub const Tag_Ok: root::Tag = 0;
    pub const Tag_CallBackIdType: root::Tag = 1;
    pub type Tag = i32;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union Value {
        pub empty: root::Nothing,
        pub callback_id: u64,
        pub error_msg: [::std::os::raw::c_char; 200usize],
        _bindgen_union_align: [u64; 25usize],
    }
    #[test]
    fn bindgen_test_layout_Value() {
        assert_eq!(
            ::std::mem::size_of::<Value>(),
            200usize,
            concat!("Size of: ", stringify!(Value))
        );
        assert_eq!(
            ::std::mem::align_of::<Value>(),
            8usize,
            concat!("Alignment of ", stringify!(Value))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Value>())).empty as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Value),
                "::",
                stringify!(empty)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Value>())).callback_id as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Value),
                "::",
                stringify!(callback_id)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<Value>())).error_msg as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(Value),
                "::",
                stringify!(error_msg)
            )
        );
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct RustResult {
        pub tag: root::Tag,
        pub value: root::Value,
    }
    #[test]
    fn bindgen_test_layout_RustResult() {
        assert_eq!(
            ::std::mem::size_of::<RustResult>(),
            208usize,
            concat!("Size of: ", stringify!(RustResult))
        );
        assert_eq!(
            ::std::mem::align_of::<RustResult>(),
            8usize,
            concat!("Alignment of ", stringify!(RustResult))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RustResult>())).tag as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RustResult),
                "::",
                stringify!(tag)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RustResult>())).value as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RustResult),
                "::",
                stringify!(value)
            )
        );
    }
    extern "C" {
        pub fn nui_init() -> root::RustResult;
    }
    extern "C" {
        pub fn nui_set_rotation(arg1: ::std::os::raw::c_int) -> root::RustResult;
    }
    extern "C" {
        pub fn nui_run() -> root::RustResult;
    }
    extern "C" {
        pub fn nui_update() -> root::RustResult;
    }
    extern "C" {
        pub fn nui_release() -> root::RustResult;
    }
    extern "C" {
        pub fn register_skeleton_closure(
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: root::simple::SkeletonData,
                ),
            >,
            arg1: *mut ::std::os::raw::c_void,
        ) -> root::RustResult;
    }
    extern "C" {
        pub fn register_depth_closure(
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: root::simple::DepthFrame,
                ),
            >,
            arg1: *mut ::std::os::raw::c_void,
        ) -> root::RustResult;
    }
    extern "C" {
        pub fn register_color_closure(
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: root::simple::RGBFrame,
                ),
            >,
            arg1: *mut ::std::os::raw::c_void,
        ) -> root::RustResult;
    }
    extern "C" {
        pub fn register_user_closure(
            cb: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                    arg2: root::simple::UserFrame,
                ),
            >,
            arg1: *mut ::std::os::raw::c_void,
        ) -> root::RustResult;
    }
}
